//Двумерный массив и РЕКУРСИЯ
//индексы для строк и столбцов меняются от "О"!!!
//если рассматривать весь массив то получится самый 1й элемент
//По умолчанию Инициалиация для строк происходит с пом константы :  String.Empty   !!!
//table[0,0]  table[0,1]  table[0,2]  table[0,3]  table[0,4]
//                               (всего 5 столбиков индексы меняются от 0  до 4)
//table[1,0]  table[1,1]  table[1,2]  table[1,3]  table[1,4]   (столбики)

//Задача 1  :

// string[,] table = new string[2, 5]; // 2- строчки; 5 - столбцы
// table[1, 2] = "слово";          //Чтобы обратиться к нужному нам массиву
//                                 //1 это индекс строки 1я строка; 2 индекс столбца 2й столбик  

// for (int rows = 0; rows < 2; rows++)
// {
//     for (int columns = 0; columns < 5; columns++)
//     {
//         Console.WriteLine($"-{table[rows, columns]}-");
//         //через интерполяцию $ обращяемся к элементам массива через имя массива
//         //индекс строки и индекс столбца
//         //"-" обрамление с "-" справа и слева, увидим, что все строки выводятся
//         //но строка ничего не содержит, так как выше указали константу : String.Empty
//     }
// }

//Задача1 Сделаем тоже самое но с ЧИСЛАМИ :  Да двумерный массив :

// int[,] matrix = new int[3, 4];

// for (int rows = 0; rows < 3; rows++)   //Можно также через  i
// {
//     for (int columns = 0; columns < 4; columns++)  //Можно также через  j
//     {
//         Console.Write($"{matrix[rows, columns]} "); //Обязательно ПРОБЕЛ 
//                                                     //Вывод чисел через пробел
//     }
// Console.WriteLine();  // После строчки принудительно переход на новую строчку
//Добившись красивого вывода матрицы чисел в консоль
// }


//Задача1 Еще обратите внимание:

// int[,] matrix = new int[3, 4];

// for (int rows = 0; rows < matrix.GetLength(0); rows++)   //НОВОЕ matrix.GetLength(0)
//                           //Так можно получить кол-во строк Имя массва и GetLength
//                           //0 означает количесто строк - для нас это будет 3
//                           //эта конструкция выдаст нам 3 строки
// {
//     for (int columns = 0; columns < matrix.GetLength(1); columns++)  //НОВОЕ matrix.GetLength(1)
//                                  //Так можно получить кол-во столбцов Имя массва и GetLength
//                                  //(1) означает 4 столбца
//                                  //matrix.GetLength(1) - выдаст 4 столбца
//     {
//         Console.Write($"{matrix[rows, columns]} "); //Обязательно ПРОБЕЛ 
//                                                     //Вывод чисел через пробел
//     }
// Console.WriteLine();  // После строчки принудительно переход на новую строчку
//                       //Добившись красивого вывода матрицы чисел в консоль
// }




//Новая задача Опишем Метод который отдельно будет печатать двумерную матрицу на экран
//и заполнять ее числами :



// void PrintArray(int[,] matr) //Передаем сокращенное название Массива внутри matr, внизу тоже!!!
//Метод PrintArray - в качестве аргумента принимает двумерную таблицу чисел
//и будет печатать таблицу на экран
// {

//     for (int i = 0; i < matr.GetLength(0); i++)
//     {
//         for (int j = 0; j < matr.GetLength(1); j++)
//         {
//             Console.Write($"{matr[i, j]} ");
//         }
//         Console.WriteLine();
//     }
// }

//Далее опишем Метод коорый бужет заполнять матрицу случайными числами:

// void FillArray(int[,] matr)
// {
//     for (int i = 0; i < matr.GetLength(0); i++)
//     {
//         for (int j = 0; j < matr.GetLength(1); j++)
//         {
//             matr[i,j]=new Random().Next(1,10); 
//             //Обращаемся к конкретному элементу [i,j] и через генератор 
//             //псевдо случайных чисел
//             //заполняется массив случайными числами от 1 до 10

//         }
//     }
// }

// int[,] matrix = new int[3, 4]; //Инициализация массива 
// PrintArray(matrix);//в кач-ве аргумента переаем ту матрицу которая выше

// FillArray(matrix);
// Console.WriteLine();
// PrintArray(matrix);



//Новая задача3 с двумерным массивом
//Рука и палец
//x это позция строчки;  у это позция столбика
//координата, то есть движение вверху нужно изменить на "1"
//уменьшить на "1 номер нашей строки"
//              x-1, y
//   x, y-1      x,y      x, y+1
//              x+1, y

// int[,] pic = new int[,]
// {

//   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
//   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
//   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
//   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
//   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
//   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
//   {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
//   {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
//   {0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
//   {0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
//   {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
//   {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
//   {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
//   {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
//   {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
//   {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
//   {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
//   {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
//   {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 },
//   {0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
//   {0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
//   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 },
//   {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
// };


// void PrintImage(int[,] image)


// {

//     for (int i = 0; i < image.GetLength(0); i++)
//     {
//         for (int j = 0; j < image.GetLength(1); j++)
//         {
//             //Хитрая операция  Console.Write($"{image[i, j]} ");
//             if (image[i, j] == 0) Console.Write($"  ");
//             //Если текущий элемент image[i,j] совпадает с "0"
//             //в этом случае будем искуственно печатать пробел
//             else Console.Write($"+");
//             //В противном случае, Если это "1" то печатаем "+"
//             //Здесь только "0"  и "1"
//         }
//         Console.WriteLine();
//     }
// }

// //Далее Метод который будет закрашивать картинку:

// void FillImage(int row, int col)
// //в кач-ве агумента укажу позицию сторки и пикселя с которого
// //должны будем начать окраску
// {
//     if (pic[row, col] == 0)
//     // проверяем условие, если текущий пиксель pic с указанной позицией row  col
//     //равен 0, то есть не закрашен, в этом случае буду его красить

//     {
//         pic[row, col] = 1;
//         //красить будем "1"
//         FillImage(row - 1, col);  //Вызови, сначала поднимаемся на строчку выше
//         FillImage(row, col - 1);   //идем влево в этой строке, позицию столбика на -1
//         FillImage(row + 1, col);   //идем вниз, увеличить позицию строки
//         FillImage(row, col + 1);  //идем в право оставаясь в той же строке
//     }
// }

// PrintImage(pic);
// FillImage(13, 13);  //например, это точка, которая должна быть внутри нашего изображения
// PrintImage(pic);

//Метод(функция) который вызывает сам себя называется РЕКУРСИЕЙ  !!!





//Новая задача 4: Факториал 5! = 5*4*3*2*1
//  или это  5 * 4!
//               4*3!
//                 3*2!
//Напишем кодом:

// int Factorial(int n) //метод который принимает Ф и возвращает Факториал этого числа
// {
//     //Опредедление факториала:1! = 1
//     //0!  = 1
//     if (n == 1) return 1;   //если n=1 вернуть 1
//     else return n * Factorial(n - 1);  //обязательно указать
//                                        //что должны возвращать значение        
// }

// Console.WriteLine("Факториал равен : " + Factorial(3)); //Факториал 3 это : 3! = 1*2*3 = 6

//Есть проблема!!! Если большие цифры:

// double Factorial(int n) //метод который принимает Ф и возвращает Факториал этого числа
// {
//     //Опредедление факториала:1! = 1
//     //0!  = 1
//     //Здесь переполнение ТИПА, есть отрицателльные число))
//     if (n == 1) return 1;   //если n=1 вернуть 1
//     else return n * Factorial(n - 1);  //обязательно указать
//                                        //что должны возвращать значение        
// }
// for (int i = 0; i < 40; i++)
// {
//     Console.WriteLine(Factorial(i));
// }

// Console.WriteLine($"{i}! = {Factorial(i)}");




//Новая задача Цифры Фибоначчи - где каждое следующее число задается через предыдущее
//1 1 2 3 5 8 13 21
//Fn = F(n-1)  + F(n-2)
//F(1) = 1 ;  F(2)  =  1

double Fibonacci(int n)
{
    if (n == 1 || n == 2) return 1;
    else return Fibonacci(n - 1) + Fibonacci(n - 2);
}
for (int i = 1; i < 50; i++)
{
    Console.WriteLine($"f({i}) = {Fibonacci(i)}");
}

